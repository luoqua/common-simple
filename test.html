<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>common-simple</title>
  </head>
  <body>
    <div id="app"></div>


    <div id="form">
    	<input type="text" name="" class="use_district">
    	<input type="number" name=""  class="user_phone">
    	<button id="btn"></button>
    </div>
    <!-- built files will be auto injected -->
    <script type="text/javascript" src="static/lInput.js"></script>
    <script type="text/javascript" src="static/promise_demo.js"></script>
    <script type="text/javascript">
var options = {
	parent: 'form',
	selectType: 'id', // 支持class、name 的选择
	btn: 'btn',
	needfields: [
		{
			fieldName: 'phone',
			isRequired: true,
			Regxp: '',
			err_null_msg: '请填写您的号码',
			err_rxp_msg: '请填写正确的手机号码'
		},
		{
			fieldName: 'district',
			isRequired: true,
			Regxp: '',
			err_null_msg: '请填写您的装修地址',
			err_rxp_msg: '请填写正确的装修地址'
		}
	],
	formfields: {
		phone: '.user_phone',
		district: '.user_district'
	},
	hostApi: 'asdasd'
}



var aa = Promise.resolve("foo")
  // 1. 接收 "foo" 并与 "bar" 拼接，并将其结果做为下一个resolve返回。
  .then(function(string) {
    return new Promise(function(resolve, reject) {
      setTimeout(function() {
        string += 'bar';
        resolve(string);
      }, 1);
    });
  })
  // 2. 接收 "foobar", 放入一个异步函数中处理该字符串
  // 并将其打印到控制台中, 但是不将处理后的字符串返回到下一个。
  .then(function(string) {
    setTimeout(function() {
      string += 'baz';
      console.log(string);
    }, 1)
    return string;
  })
  // 3. 打印本节中代码将如何运行的帮助消息，
  // 字符串实际上是由上一个回调函数之前的那块异步代码处理的。
  .then(function(string) {
    console.log("Last Then:  oops... didn't bother to instantiate and return " +
                "a promise in the prior then so the sequence may be a bit " +
                "surprising");

    // 注意 `string` 这时不会存在 'baz'。
    // 因为这是发生在我们通过setTimeout模拟的异步函数中。
    console.log(string);
}).finally(function(){
	throw 'no NO'
})


    </script>
  </body>
</html>
